## 作用域

javascript 是如何存储变量的？以及如何访问这些变量？

### 编译原理

程序中的一段源码在执行之前会经历三个步骤，称为编译

- 分词/词法分析
	- 将代码字符串分解成有意义的代码块，这些代码块称为`词法单元(token)`
	- 比如:`var a = 2`分解后的词法单元为
		- `var`
		- `a`
		- `=`
		- `2`
		- `;`
	- 词法分析 - 分词之后，如果这个单元属于另一个单元，也就是这个单元会有状态，这就被称为词法分析
- 解析/语法解析
	- 将词法单元解析为抽象语法树`AST`
- 代码生成
	- 将 AST 转换成可执行代码的过程称为代码生成

JavaScript 是一边编译一边执行，所以在编译阶段做了很多优化。
### JavaScript 中的编译

 **编译原理**
 
	- 引擎 - 代码执行
	- 编译器 - 语法分析，代码生成
	- 作用域 - 收集维护标识符（变量）

**作用域规则**
	- LHS查询
		- 当变量出现在赋值操作的左侧时
		- 赋值操作的目标是谁
		- 查询失败会创建一个变量，严格模式下`ReferenceError`
	- RHS查询
		- 当变量出现在赋值操作的右侧时
		- 非左侧
		- 函数参数会进行 RHS 查询
		- 谁是赋值操作的源头
		- 未找到时`ReferenceError`
**作用域类型**
	- 词法作用域 - js - 作用域
		- 作用域是静态的
		- 定义在词法阶段的作用域，也就是你写代码时的位置
		- 词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则，特征发生在书写阶段
		- 关键点-作用域变量查找是基于函数定义的位置，跟调用位置没有关系！这也是词法作用域的特点
	- 动态作用域 - bash，`this`
		- 作用域是动态的
		- 比如 `this`
	- 欺骗词法作用域
		- `eval`
		- `with`
	- 函数作用域/块作用域
		- `function(){}`
		- `{}`
- 声明提升
	- `var` 声明的变量会提升至顶部，且值为`undefined`
	- `function` 声明也会提升至顶部，且值为定义的函数，并不是`undefined`
- 闭包
	- 当函数可以记住并访问所在的词法作用域时，就产生了闭包
	- 该函数依然持有对该作用域的引用，而这个引用就叫作闭包
- 箭头函数的`this`
	- 词法作用？ - 叫 this词法
## this和对象原型

- 动态作用域
- 调用位置
	- 调用栈中的第二个元素就是调用位置
- 调用规则 - 多个规则，优先级按照以下顺序
	- new
	- call/apply 显示绑定
		- `null`,`undefine`为上下文参数时，将会转化为默认绑定
	- 上下文隐式绑定
	- 默认绑定
		- 严格模式为`undefined`
## 对象
- `for in`
- `for of` - 迭代器

Class

优点
缺点
	动态性
	super问题
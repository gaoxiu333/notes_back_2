# 模块

模块简史

## 导出/导入

这是我们在本节和前面章节中介绍的所有 `export` 类型：

你可以阅读并回忆它们的含义来进行自查：

- 在声明一个 class/function/… 之前：
  - `export [default] class/function/variable ...`
- 独立的导出：
  - `export {x [as y], ...}`.
- 重新导出：
  - `export {x [as y], ...} from "module"`
  - `export * from "module"`（不会重新导出默认的导出）。
  - `export {default [as y]} from "module"`（重新导出默认的导出）。

导入：

- 导入命名的导出：
  - `import {x [as y], ...} from "module"`
- 导入默认的导出：
  - `import x from "module"`
  - `import {default as x} from "module"`
- 导入所有：
  - `import * as obj from "module"`
- 导入模块（其代码，并运行），但不要将其任何导出赋值给变量：
  - `import "module"`

我们把 `import/export` 语句放在脚本的顶部或底部，都没关系。

因此，从技术上讲，下面这样的代码没有问题：

```javascript
sayHi();

// ...

import {sayHi} from './say.js'; // 在文件底部导入
```

在实际开发中，导入通常位于文件的开头，但是这只是为了更加方便。

**请注意在 `{...}` 中的 import/export 语句无效。**

像这样的有条件的导入是无效的：

```javascript
if (something) {
  import {sayHi} from "./say.js"; // Error: import must be at top level
}
```

……但是，如果我们真的需要根据某些条件来进行导入呢？或者在某些合适的时间？例如，根据请求（request）加载模块，什么时候才是真正需要呢？

## 动态导入

`import(module)` 表达式加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。我们可以在代码中的任意位置调用这个表达式。

```js
async function load() {
    let say = await import('./say.js');
    say.hi(); // Hello!
    say.bye(); // Bye!
    say.default(); // Module loaded (export default)!
  }
```


# fiber

React 老架构的调度算法：

- **同步递归**的方式进行遍历渲染，
- 无法**暂停和恢复**
- 解决方案：
  - 当遇到同步阻塞任务时：任务分割、异步调用、缓存策略，三个解决思路
  - React Fiber 是任务分割的实现

> Fiber 架构的核心是：
>
> - 任务拆分
> - 协同
> - 主动把执行权交给主线程，使主线程有时间空档处理其他高优先级任务。

React 合作式调度

- 渲染更新把更新过程拆分成多个小人物，每次只做小部分，如果有时间继续下一个任务，没有就挂起任务
- 合作式调度主要用来分配任务
- 有任务更新时，把当前的更新送入 Update Queue 中，然后交给 Scheduler
- Scheduler 根据当前主线程的使用情况去处理 Update Queue
- 根据优先级不同：
  - 低优先级由 `requestIdleCallback` API 实现
  - 高优先级由 `reuqestAnimationFrame` API 实现

Fiber

- 可以说是一种数据结构（堆栈帧）
- 也可以说是解决可中断任务的一种解决方案
- 特性：
  - 时间分片
  - 暂停
- 渲染/更新过程（递归 `diff`）拆分为一系列小任务，每次检查树上的一小部分，完成后检查是否还有时间继续下个任务，有的话继续，没有的话自己挂起，主线程不忙的时候再继续。
- Fiber Tree 通过节点保存与映射，便能够随时地进行停止和重启，这样便能达到实现 **任务分割** 的基本前提。
- 采用的是 **双缓冲技术（double buffering）** 从 Fiber Tree 中获取 DOM Change List
  - 更新的时候 current 指向最新的生成的树



## Hooks

React Hook 是一种复用状态逻辑的方式。方便共享状态逻辑



- hooks
- 函数组件
  - SFC，没有 `state`
- 类组件
  - 能处理更复杂的逻辑

#### 类组件的问题

- **代码复用：在组件之间复用状态逻辑很难**
- **复杂组件变得难以理解**
- **难以理解的 Class**
  - 需要理解 `this` 的工作方式，不能忘记绑定事件处理器

Hooks 优点

- 更函数式、更新颗粒度更细、代码更清晰
- 多个状态不会产生嵌套，写法还是平铺的：如 `async/await` 之于 `callback hell` 一样，Hooks 也解决了高阶组件的嵌套地狱问题。虽然 `render props` 也可以通过 `compose` 解决这个问题，但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量。
- Hooks 可以引用其他 Hooks，自定义 Hooks 更加灵活。
- 更容易将组件的 UI 与状态分离。




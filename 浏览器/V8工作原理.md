# V8 工作原理

## javascript内存机制（堆空间/栈空间）

理解V8的工作原理需要理解数据在内存中的存放、javascript处理垃圾回收、V8执行代码。

了解javascript得内存机制之前先确定js的是什么类型的语言

![img](https://blog.poetries.top/img/static/gitee/2019/11/2.png)

从上图中可以看出，javascript是：

- 弱类型：不需要告诉js引擎变量是什么类型，js引擎在运行代码的时候会自己计算出来
- 动态：一个变量可以保存不同类型的数据。

### javascript 中的数据类型一共有8种：

![img](https://blog.poetries.top/img/static/gitee/2019/11/3.png)

- 原始类型：前七种类型

- 引用类型：Object为引用类型。

  > 两种类型在内存中存放的位置不一样。

### 内存空间

javascript的内存模型：

![img](https://blog.poetries.top/img/static/gitee/2019/11/4.png)

javascript在执行过程中主要有三种内存空间：

- 代码空间
- 栈空间
- 堆空间

### 栈空间/堆空间

栈空间就是调用栈，用来存储执行上下文；一下是栈空间存储数据的模型：

![img](https://blog.poetries.top/img/static/gitee/2019/11/6.png)

左侧为栈空间，右侧为堆空间，栈空间变量的值为引用类型时，引用类型的数据存放在堆空间；

> 为什么引用类型不能存放在栈空间中？
>
> 因为javascript引擎需要栈来维护程序执行期间的上下文，比如：一个函数执行完后，指针下移，离开当前执行函数上下文，当前执行函数的栈空间全部回收；空间越大执行函数的内存分配和回收都会占用一定的时间，将会话费更多的时间（如果执行上下文变量占用更多内存的话），所以存放在堆中。
>
> ![img](https://blog.poetries.top/img/static/gitee/2019/11/7.png)

### 闭包（从js内存机制理解闭包）

定义一个外部函数，返回一个内部函数；

js引擎执行到这个外部函数时，首先会编译并创建一个空的执行上下文；编译过程中，遇到内部函数，js引擎会对内部函数做一次快速的词法扫描，发现内部函数内引用了外部函数的变量，js引擎会判断这是一个闭包，于是创建了一个'closure'的对象，用来存放内部函数引用的外部函数变量，没有引用的不会存放。当外部函数执行完后只想上下文被销毁，closure因为被返回的内部函数使用，继续留在堆中。

> 产生闭包的核心步骤：
>
> - 一：扫描内部函数
> - 二：把内部函数引用的外部变量保存到堆中

## 垃圾回收

javascript使用自动垃圾回收的策略，产生的垃圾数据是由垃圾回收器释放的，并不需要手动通过代码来释放。

> 垃圾回收策略往往没有一个完美的解决方案，权衡利弊；两害相权取其轻；两利相权取其重，以求利益最大化。

### 调用栈垃圾回收

函数执行时，会被压入调用栈中，调用栈存放在栈内存中，同时还有一个记录当前执行状态的指针（ESP）；

当函数执行时，ESP下移到该函数的执行上下文，执行完后，ESP移除该函数的上下文，该函数的执行上下文被销毁

![img](https://blog.poetries.top/img/static/gitee/2019/11/11.png)

从图中可以看出，js引擎通过下移ESP来销毁该函数保存在栈中的执行上下文。

### 堆中的垃圾回收

当函数执行结束ESP下移，该函数的执行上下文被销毁，但是保存在堆中的引用对象还在；

存放在堆中的数据需要用js中的垃圾回收器。

一下介绍V8垃圾回收器的知识：

#### 代际假说和分代收集

- 代际假说：

  - 一种情况是大部分对象在内存中存在的时间很短，就是很多对象一经分配内存，很快就变得不可访问。
  - 另一种情况是对象会存活很久。

  > 简单理解代际假说意思就是说，要么对象就临时用一下就不用了，或者会一直使用。

基于这个假说V8把堆分为新生代和老生代两个区域：

- 新生代：存放的是生存时间短的对象
- 老生代：存放时间久的对象。

> 新生代通常只支持1～8M容量，使用副垃圾回收器；老生代通常很大，使用主垃圾回收器。

#### 垃圾回收的工作流程

无论新老生代都遵循一套共同代执行流程。

- 标记空间中的活动对象和非活动对象（活动对象：还在使用的对象，反之为非活动对象，非活动对象进入垃圾回收）

- 回收非活动对象占据的内存。

- 标记完成后统一情况所有被标记为可回收的对象

- 最后进行内存整理；

  > 频繁回收对象后，内存中会存在大量不连续的空间，被称为内存碎片；当内存空间中存在大量内存碎片后，如果后续需要分配较大的连续内存时有可能出现内存不足的情况，这一步是可选的。

#### 副垃圾回收器

主要负责新生代的垃圾回收，通常是一些小的对象，内存不大但是会比较频繁。

新生代使用Scavenge算法来处理：所谓Scavenge算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域；

![img](https://blog.poetries.top/img/static/gitee/2019/11/13.png)

算法原理：

- 新加入的对象存放在对象区域，当对象区域快写满时，执行一次垃圾清理操作
- 垃圾清理操作过程中，首先对对象区域中的垃圾做标记，标记完后进入清理阶段；
- 副垃圾回收器会把还存活的对象复制到空闲区域，同时还会把这些对象有序排列起来（因为对内存进行了排序这个复制的操作也同时完成了内存整理，也就不会产生内存碎片了）；
- 复制完成后，对象区域和空闲区域互换，原来的对象区域变为空闲区域，原来的空闲区域变为对象区域。

> 由于每次执行清理操作需要互换两个区域，如果空间设置的太大，清理的时间就会过长，所以为了效率，一般新生区的空间设置的比较小。

对象晋升策略：由于新生代空间不大，很容易被存活的对象装满；js引擎采用了对象晋升策略，经过两次垃圾回收依然存活的对象会被移到老生区。

#### 主垃圾回收器

主垃圾回收器主要负责老生区中的垃圾回收。除了新生区晋升的对象，一些大的对象会直接分配的老生区。所以老生区中的对象有两个特点：

- 一个是对象占用空间大
- 一个是对象存活时间长

> 基于以上两个特点，使用Scavenge算法既占用一半的空间，又会因为对象太大花费更多的时间复制；

主垃圾回收采用标记-清除（Mark-Sweep）的算法进行垃圾回收；

标记-清楚算法原理：

- 首先是标记阶段，从一组跟元素开始，递归遍历这组跟元素，被引用的对象成为活动对象，没有被引用的对象被判断为垃圾数据。

  ![img](https://blog.poetries.top/img/static/gitee/2019/11/14.png)

- 结下来是垃圾清除的过程；

  ![img](https://blog.poetries.top/img/static/gitee/2019/11/15.png)

  > 以上就是对标记清除算法的简单理解，多次执行后会产生大量不连续的内存碎片

  标记-整理（Mark-Compact）

  过程和标记-清除的算法一样，只是后续清理的步骤换成了整理；就是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存：

  ![img](https://blog.poetries.top/img/static/gitee/2019/11/16.png)

  ### 全停顿

  由于js运行在主线程上，一旦执行垃圾回收算法，需要将执行的js脚本暂停下来，等待垃圾回收完毕恢复脚本执行，这个行为叫做全停顿。

  ![img](https://blog.poetries.top/img/static/gitee/2019/11/17.png)

  > 如果js堆中的数据过大，执行一次垃圾回收的时间就越久，这个花费直观的感受就是应用的性能和响应都会直线下降，体验很差。

  全停顿的优化：

  使用增量标记（Incremental Marking）：为了降低老生代的垃圾回收造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和js应用逻辑交替进行，直到标记阶段完成，

  ![img](https://blog.poetries.top/img/static/gitee/2019/11/18.png)

  > 增量算法，可以把一个完整的垃圾回收任务拆分为很多的小任务，这些小任务执行的时间比较短，可以穿插在其他js任务中间，这样就不会因为垃圾回收感受到应用到卡顿。

## V8如何执行一段javascript代码

了解V8的执行机制，更深入理解语言转换器Babel、语法检查工具ESLint，前端框架Vue、React的底层实现机制。

深入理解V8工作原理需要理解编译器（Compiler）、解释器（Interpreter）、抽象语法书（AST）、字节码（Bytecode）、即时编译器（JIT）等概念。

### 编译器和解释器

之所以需要编译器和解释器是因为机器不能直接理解我们缩写的代码，需要被翻译成机器读懂的代码。

按照语言的执行流程，可以把语言划分为编译行语言和解释型语言。

编译型语言：编译型语言在执行之前需要经过编译器的编译，并且编译之后直接保留机器能读懂的二进制文件，这样每次执行程序时直接执行二机制文件，不需要再重新编译了，如C/C++/GO

解释型语言：每次运行都需要通过解释器对程序进行动态解释和执行，如Python、javascrtipt

### 执行过程

![img](https://blog.poetries.top/img/static/gitee/2019/11/19.png)

> 编译型语言：编译器首先一次对源码进行词法分析、语法分析生成抽象语法书（AST），然后是优化代码，最后生成机器码。如果编译成功生成可执行文件，如果编译过程发生语或其他错误，那么编译抛出异常。
>
> 解释型语言：首先对源代码进行词法分析、语法分析，并生成抽象语法树（AST），再基于抽象语法树生成字节码，最后根据字节码来执行程序、输出结果。

#### V8如何执行？

![img](https://blog.poetries.top/img/static/gitee/2019/11/20.png)

V8在执行过程中既有解释器（Ignition），又有编译器（TurboFan）。

1. 生成抽象语法树（AST）和执行上下文

   源代码被转换成AST并生成执行上下文，生成的AST结构如下：

   ```js
   var myName = " 极客时间 "
   function foo(){
     return 23;
   }
   myName = "geektime"
   foo()
   ```

   

   ![img](https://blog.poetries.top/img/static/gitee/2019/11/21.png)

   > 参考 javascript-ast 生成抽象语法树。

   如何生成抽象语法书呢？

   ##### 首先是分词（tokenize）又称为词法分析。

   将一行行的源码拆分成一个个token，token是语法上不可再分的最小的单个字符或字符串

   ![img](https://blog.poetries.top/img/static/gitee/2019/11/22.png)

   ##### 其次是解析（parse）又称为语法分析

   将上一步生成的token数据，根据语法规则转为AST，如果源码符合语法规则会顺利生成，如果源码存在错误，这一步会终止，并抛出语法错误。

   > AST生成过程为：先词法分析解析成token；再语法分析根据语法规则生成AST。

2. 生成字节码

   有了AST和执行上下文，解释器会根据AST生成字节码，并解释执行字节码。

   > V8一开始是没有字节码的，是直接将AST转为机器码；机器码执行效率非常高效，随着chrom在手机上运行，特别是小内存的手机，内存占用问题也暴露出来了，因为V8需要消耗大量的内存来存放转换后的机器码；为了解决内存问题V8引入了字节码。

   什么是字节码？

   字节码是介于AST和机器码之间的一种代码，字节码需要通过解释器将其转换为机器码后才能执行。

   下图为高级代码、字节码、机器码内存占用：

   ![img](https://blog.poetries.top/img/static/gitee/2019/11/23.png)

   

3. 执行代码

   - 解释器：如果执行一段第一次执行的字节码，解释器会逐条解释执行；如果一段字节码被重复执行多次，这段代码被称为热点代码（HotSpot）。

   - 编译器：编译器会把这段热点字节码编译为高效的机器码，再次执行就不需要再经过解释器解释了。

     > 解释器（Ignition）是点火器的意思；
     >
     > 编译器（TurboFan）是涡轮增压的意思。
     >
     > 寓意代码启动时通过点火器慢慢发动，一旦启动涡轮增压介入，执行效率随着执行时间越来越高效。

     即使编译（JIT）：我们把字节码配合解释器和编译器执行代码的技术称为即使编译；在V8中解释器执行字节码的同时，收集代码的信息，当它发现某一处代码变热后，编译器把热点代码转换为机器码，并把转换后的机器码保存起来，备再次使用。

     ![img](https://blog.poetries.top/img/static/gitee/2019/11/24.png)

     ### javascript性能优化

     - 提升单次脚本的执行速度，避免js的长任务霸占主线程，这样可以使页面快速响应交互；
     - 避免大的内联脚本，因为解析HTML的过程中，解析和编译也会占用主线程
     - 较少js文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存

     


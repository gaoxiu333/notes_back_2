# V8 工作原理

## javascript内存机制（堆空间/栈空间）

理解V8的工作原理需要理解数据在内存中的存放、javascript处理垃圾回收、V8执行代码。

了解javascript得内存机制之前先确定js的是什么类型的语言

![img](https://blog.poetries.top/img/static/gitee/2019/11/2.png)

从上图中可以看出，javascript是：

- 弱类型：不需要告诉js引擎变量是什么类型，js引擎在运行代码的时候会自己计算出来
- 动态：一个变量可以保存不同类型的数据。

### javascript 中的数据类型一共有8种：

![img](https://blog.poetries.top/img/static/gitee/2019/11/3.png)

- 原始类型：前七种类型

- 引用类型：Object为引用类型。

  > 两种类型在内存中存放的位置不一样。

### 内存空间

javascript的内存模型：

![img](https://blog.poetries.top/img/static/gitee/2019/11/4.png)

javascript在执行过程中主要有三种内存空间：

- 代码空间
- 栈空间
- 堆空间

### 栈空间/堆空间

栈空间就是调用栈，用来存储执行上下文；一下是栈空间存储数据的模型：

![img](https://blog.poetries.top/img/static/gitee/2019/11/6.png)

左侧为栈空间，右侧为堆空间，栈空间变量的值为引用类型时，引用类型的数据存放在堆空间；

> 为什么引用类型不能存放在栈空间中？
>
> 因为javascript引擎需要栈来维护程序执行期间的上下文，比如：一个函数执行完后，指针下移，离开当前执行函数上下文，当前执行函数的栈空间全部回收；空间越大执行函数的内存分配和回收都会占用一定的时间，将会话费更多的时间（如果执行上下文变量占用更多内存的话），所以存放在堆中。
>
> ![img](https://blog.poetries.top/img/static/gitee/2019/11/7.png)

### 闭包（从js内存机制理解闭包）

定义一个外部函数，返回一个内部函数；

js引擎执行到这个外部函数时，首先会编译并创建一个空的执行上下文；编译过程中，遇到内部函数，js引擎会对内部函数做一次快速的词法扫描，发现内部函数内引用了外部函数的变量，js引擎会判断这是一个闭包，于是创建了一个'closure'的对象，用来存放内部函数引用的外部函数变量，没有引用的不会存放。当外部函数执行完后只想上下文被销毁，closure因为被返回的内部函数使用，继续留在堆中。

> 产生闭包的核心步骤：
>
> - 一：扫描内部函数
> - 二：把内部函数引用的外部变量保存到堆中

## 垃圾回收

javascript使用自动垃圾回收的策略，产生的垃圾数据是由垃圾回收器释放的，并不需要手动通过代码来释放。

> 垃圾回收策略往往没有一个完美的解决方案，权衡利弊；两害相权取其轻；两利相权取其重，以求利益最大化。

### 调用栈垃圾回收

函数执行时，会被压入调用栈中，调用栈存放在栈内存中，同时还有一个记录当前执行状态的指针（ESP）；

当函数执行时，ESP下移到该函数的执行上下文，执行完后，ESP移除该函数的上下文，该函数的执行上下文被销毁

![img](https://blog.poetries.top/img/static/gitee/2019/11/11.png)

从图中可以看出，js引擎通过下移ESP来销毁该函数保存在栈中的执行上下文。

### 堆中的垃圾回收

当函数执行结束ESP下移，该函数的执行上下文被销毁，但是保存在堆中的引用对象还在；

存放在堆中的数据需要用js中的垃圾回收器。

一下介绍V8垃圾回收器的知识：

#### 代际假说和分代收集

- 代际假说：

  - 一种情况是大部分对象在内存中存在的时间很短，就是很多对象一经分配内存，很快就变得不可访问。
  - 另一种情况是对象会存活很久。

  > 简单理解代际假说意思就是说，要么对象就临时用一下就不用了，或者会一直使用。

基于这个假说V8把堆分为新生代和老生代两个区域：

- 新生代：存放的是生存时间短的对象
- 老生代：存放时间久的对象。

> 新生代通常只支持1～8M容量，使用副垃圾回收器；老生代通常很大，使用主垃圾回收器。

#### 垃圾回收的工作流程

无论新老生代都遵循一套共同代执行流程。

- 标记空间中的活动对象和非活动对象（活动对象：还在使用的对象，反之为非活动对象，非活动对象进入垃圾回收）

- 回收非活动对象占据的内存。

- 标记完成后统一情况所有被标记为可回收的对象

- 最后进行内存整理；

  > 频繁回收对象后，内存中会存在大量不连续的空间，被称为内存碎片；当内存空间中存在大量内存碎片后，如果后续需要分配较大的连续内存时有可能出现内存不足的情况，这一步是可选的。

#### 副垃圾回收器

主要负责新生代的垃圾回收，通常是一些小的对象，内存不大但是会比较频繁。

新生代使用Scavenge算法来处理：所谓Scavenge算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域；

![img](https://blog.poetries.top/img/static/gitee/2019/11/13.png)

算法原理：

- 新加入的对象存放在对象区域，当对象区域快写满时，执行一次垃圾清理操作
- 垃圾清理操作过程中，首先对对象区域中的垃圾做标记，标记完后进入清理阶段；
- 副垃圾回收器会把还存活的对象复制到空闲区域，同时还会把这些对象有序排列起来（因为对内存进行了排序这个复制的操作也同时完成了内存整理，也就不会产生内存碎片了）；
- 复制完成后，对象区域和空闲区域互换，原来的对象区域变为空闲区域，原来的空闲区域变为对象区域。

> 由于每次执行清理操作需要互换两个区域，如果空间设置的太大，清理的时间就会过长，所以为了效率，一般新生区的空间设置的比较小。

对象晋升策略：由于新生代空间不大，很容易被存活的对象装满；js引擎采用了对象晋升策略，经过两次垃圾回收依然存活的对象会被移到老生区。

#### 主垃圾回收器

主垃圾回收器主要负责老生区中的垃圾回收。除了新生区晋升的对象，一些大的对象会直接分配的老生区。所以老生区中的对象有两个特点：

- 一个是对象占用空间大
- 一个是对象存活时间长

> 基于以上两个特点，使用Scavenge算法既占用一半的空间，又会因为对象太大花费更多的时间复制；

主垃圾回收采用标记-清除（Mark-Sweep）的算法进行垃圾回收；

标记-清楚算法原理：

- 首先是标记阶段，从一组跟元素开始，递归遍历这组跟元素，被引用的对象成为活动对象，没有被引用的对象被判断为垃圾数据。

  ![img](https://blog.poetries.top/img/static/gitee/2019/11/14.png)

- 结下来是垃圾清除的过程；

  ![img](https://blog.poetries.top/img/static/gitee/2019/11/15.png)

  > 以上就是对标记清除算法的简单理解，多次执行后会产生大量不连续的内存碎片

  标记-整理（Mark-Compact）

  过程和标记-清除的算法一样，只是后续清理的步骤换成了整理；就是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存：

  ![img](https://blog.poetries.top/img/static/gitee/2019/11/16.png)

  ### 全停顿

  由于js运行在主线程上，一旦执行垃圾回收算法，需要将执行的js脚本暂停下来，等待垃圾回收完毕恢复脚本执行，这个行为叫做全停顿。

  ![img](https://blog.poetries.top/img/static/gitee/2019/11/17.png)

  > 如果js堆中的数据过大，执行一次垃圾回收的时间就越久，这个花费直观的感受就是应用的性能和响应都会直线下降，体验很差。

  全停顿的优化：

  使用增量标记（Incremental Marking）：为了降低老生代的垃圾回收造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和js应用逻辑交替进行，直到标记阶段完成，

  ![img](https://blog.poetries.top/img/static/gitee/2019/11/18.png)

  > 增量算法，可以把一个完整的垃圾回收任务拆分为很多的小任务，这些小任务执行的时间比较短，可以穿插在其他js任务中间，这样就不会因为垃圾回收感受到应用到卡顿。

  


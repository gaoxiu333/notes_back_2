# 浏览器的渲染进程

浏览器将html、css、javascript经过解析渲染成我们看到的页面。

### 渲染过程

浏览器渲染过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的html经过这些子阶段最后输出像素。

![img](/Users/work/Desktop/private/note/imags/浏览器渲染进程1.png)

按照渲染的时间顺序，可以分为如下几个子阶段：

- 构建DOM树
- 样式计算
- 布局阶段
- 分层
- 绘制
- 分块
- 光栅化和合成

*每个阶段需要关注：*

 - *每个子阶段的输入内容*
 - *每个子阶段的处理过程*
 - *每个子阶段的输出内容*

### 构建DOM树

因为浏览器无法直接理解HTML，所以需要将HTML转换为浏览器能理解的的结构，也就是DOM树。

![img](/Users/work/Desktop/private/note/imags/渲染进程2.png)

从图中可以看出，构建DOM树的输入内容是一个非常简单的HTML文件，然后经由HTML解析器解析，最终输出树状结构的DOM。

### 样式计算

已经有了DOM树，但是DOM节点的样式我们依然不知道，要让DOM节点拥有正确的样式，这就需要计算样式了；样式计算的目的是为了计算出DOM节点中每个元素的具体样式，这个阶段大概分为三步。

1. **把css转换为浏览器能够理解的结构**

   首先要拿到css样式，通过以下三种方式拿到：

   ![img](/Users/work/Desktop/private/note/imags/渲染进程3.png)

   - 通过link引用的外部css文件
   - `style`标记内的css
   - 元素的style属性内嵌的css

   和浏览器一样，浏览器无法直接理解这些css样式，所以当渲染引擎接受到css文本时，会执行一个转换操作，将css文本转换为浏览器可以理解的结构**styleSheets**，通过`docuument.styleSheets`可以看到其结构。

2. **转换样式表中的属性值，使其标准化**

   这个时候css文本已经转换为浏览器可以理解的机构了，结下来要对其进行属性值的标准化。

   ![img](/Users/work/Desktop/private/note/imags/渲染进程4.png)

   css中存在如2em，blue，bold，这些类型的数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

3. **计算出DOM树中每个节点的具体样式**

   现在的样式属性已经被标准化，接下来需要计算DOM树中每个节点的样式属性，涉及到css的**继承规则**和**层叠规则**。

   **CSS继承**

   css继承就是每个DOM节点都包含父节点的样式。如下：

   ```css
   body { font-size: 20px }
   p {color:blue;}
   span  {display: none}
   div {font-weight: bold;color:red}
   div  p {color:green;}
   
   ```

   ![img](/Users/work/Desktop/private/note/imags/渲染进程5.png)

   `body`节点的`font-size:20px`被body节点下的所有节点继承，都是`font-size:20px`。

   通过控制台加深理解：

   ![img](/Users/work/Desktop/private/note/imags/06.png)

   **CSS层叠规则**

   层叠是css的基本特征，它定义了如何合并来自多个源的属性值的算法。

### 布局阶段

现在我们有DOM树和DOM树中元素的样式，但不足以显示页面，因为还不知道DOM元素的几何位置信息。

计算DOM树中可见元素的几何位置，这个计算过程叫做布局。布局阶段有两个任务，创建布局树和布局计算。

1. **创建布局树**

   ![img](/Users/work/Desktop/private/note/imags/7.png)

   从上图可以看出，DOM树中所有不可见的节点都没有包含到布局树中。

   为了构建布局树，浏览器大体上完成了下面这些工作

   - 遍历DOM树中的所有可见节点，并把这些节点加到布局中；
   - 而不可见的节点会被布局树忽略掉，如`head`标签下面的全部内容，再比如`body.p.span`这个元素，因为它的属性包含 `dispaly:none`，所以这个元素也没有被包进布局树

2. **布局计算**

   在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome团队正在重构布局代码，下一代布局系统叫LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

   ##  





​			




# 浏览器的渲染进程

浏览器将html、css、javascript经过解析渲染成我们看到的页面。

### 渲染过程

浏览器渲染过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的html经过这些子阶段最后输出像素。

![img](/Users/work/Desktop/private/note/imags/浏览器渲染进程1.png)

按照渲染的时间顺序，可以分为如下几个子阶段：

- 构建DOM树
- 样式计算
- 布局阶段
- 分层
- 绘制
- 分块
- 光栅化和合成

*每个阶段需要关注：*

 - *每个子阶段的输入内容*
 - *每个子阶段的处理过程*
 - *每个子阶段的输出内容*

### 构建DOM树

因为浏览器无法直接理解HTML，所以需要将HTML转换为浏览器能理解的的结构，也就是DOM树。

![img](/Users/work/Desktop/private/note/imags/渲染进程2.png)

从图中可以看出，构建DOM树的输入内容是一个非常简单的HTML文件，然后经由HTML解析器解析，最终输出树状结构的DOM。

### 样式计算

已经有了DOM树，但是DOM节点的样式我们依然不知道，要让DOM节点拥有正确的样式，这就需要计算样式了；样式计算的目的是为了计算出DOM节点中每个元素的具体样式，这个阶段大概分为三步。

1. **把css转换为浏览器能够理解的结构**

   首先要拿到css样式，通过以下三种方式拿到：

   ![img](/Users/work/Desktop/private/note/imags/渲染进程3.png)

   - 通过link引用的外部css文件
   - `style`标记内的css
   - 元素的style属性内嵌的css

   和浏览器一样，浏览器无法直接理解这些css样式，所以当渲染引擎接受到css文本时，会执行一个转换操作，将css文本转换为浏览器可以理解的结构**styleSheets**，通过`docuument.styleSheets`可以看到其结构。

2. **转换样式表中的属性值，使其标准化**

   这个时候css文本已经转换为浏览器可以理解的机构了，结下来要对其进行属性值的标准化。

   ![img](/Users/work/Desktop/private/note/imags/渲染进程4.png)

   css中存在如2em，blue，bold，这些类型的数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

3. **计算出DOM树中每个节点的具体样式**

   现在的样式属性已经被标准化，接下来需要计算DOM树中每个节点的样式属性，涉及到css的**继承规则**和**层叠规则**。

   **CSS继承**

   css继承就是每个DOM节点都包含父节点的样式。如下：

   ```css
   body { font-size: 20px }
   p {color:blue;}
   span  {display: none}
   div {font-weight: bold;color:red}
   div  p {color:green;}
   
   ```

   ![img](/Users/work/Desktop/private/note/imags/渲染进程5.png)

   `body`节点的`font-size:20px`被body节点下的所有节点继承，都是`font-size:20px`。

   通过控制台加深理解：

   ![img](/Users/work/Desktop/private/note/imags/06.png)

   **CSS层叠规则**

   层叠是css的基本特征，它定义了如何合并来自多个源的属性值的算法。

### 布局阶段

现在我们有DOM树和DOM树中元素的样式，但不足以显示页面，因为还不知道DOM元素的几何位置信息。

计算DOM树中可见元素的几何位置，这个计算过程叫做布局。布局阶段有两个任务，创建布局树和布局计算。

1. **创建布局树**

   ![img](/Users/work/Desktop/private/note/imags/7.png)

   从上图可以看出，DOM树中所有不可见的节点都没有包含到布局树中。

   为了构建布局树，浏览器大体上完成了下面这些工作

   - 遍历DOM树中的所有可见节点，并把这些节点加到布局中；
   - 而不可见的节点会被布局树忽略掉，如`head`标签下面的全部内容，再比如`body.p.span`这个元素，因为它的属性包含 `dispaly:none`，所以这个元素也没有被包进布局树

2. **布局计算**

   在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome团队正在重构布局代码，下一代布局系统叫LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

   ### 分层
   
   已经有了布局树，元素位置已经结算出来 ,接下来对 z-index、3d变换、页面滚动等分层
   
   为了加深一下可以在控制台中查看`layers`,可视化页面的分层情况。
   
   下图所示，图层和布局树节点之间的关系：
   
   ![img](https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png)
   
   > 通常情况下，并不是布局树中的每个节点都包含一个图层，如果一个节点没有对应的图层，那么这个节点就从属父节点的图层，最终每个节点都从属一个图层。
   
   **拥有层叠上下文属性的元素会被提升为单独的一层**
   
   ![img](https://static001.geekbang.org/resource/image/a0/19/a03eb12053aac1ac496b61a424f20119.png)
   
   - 定位属性（明确定位属性）
   - 定义透明属性
   - css滤镜
   
   以上属性都是层叠上下文属性。
   
   **需要裁剪的地方也会被创建为图层**
   
   ```html
   <style>
         div {
               width: 200;
               height: 200;
               overflow:auto;
               background: gray;
           } 
   </style>
   <body>
       <div >
           <p>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：</p>
           <p>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。</p>
           <p>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。</p> 
       </div>
   </body>
   ```
   
   简单的理解为文本溢出切别裁剪时，或者文本溢出有滚动条时，滚动条也会被提升为单独图层（和文本不在一个图层）。

### 图层绘制

图层树构建以后，渲染引擎会对图层树中的每个图层进行绘制。

渲染引擎会把图层的绘制拆分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表：

![img](https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png)

具体可以在`layers`中查看绘制过程。

### 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，实际上绘制操作是由渲染引擎中的合成线程来完成。

![img](https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png)

如上图，当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程；

有时候有的图层可以很大，比如有的页面使用滚动条好久才能滚动到底部，但是通过视口（viewport），用户只能看到页面的很小一部分；基于这个原因，合成线程会将图层划分为图块（tile），这些图块大小通常是`256*256`或者`512*512`。然后合成线程会按照视口附近的图块来优先生成位图，**生成位图的操作叫做栅格化**

栅格化：将图块转换为位图，图块是栅格化执行的最小单位，渲染进程维护了一个栅格化的线程池，所有图块栅格化都是在线程池内执行。

GPU栅格化：栅格化过程通常会使用GPU来加速生成，也叫快速栅格化，生成的位图被保存在GPU内存中；GPU操作运行在GPU进程中，所以设计到跨进程操作。

### 合成和显示

栅格化完成后，合成线程就会生成一个绘制图块的命令 DrawQuad，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的 DrawQuad命令，然后根据命令将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

## 总结

从HTML到DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。

![img](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)

结合上图总结：

	-	渲染进程将HTML内容转换为浏览器能够读懂的DOM树结构 
	-	渲染引擎将css样式表转为浏览器可以理解的styleSheets，计算出DOM节点的样式
	-	创建布局树，并计算元素的布局信息
	-	对布局树进行分层，并生成分层树。
	-	为每个图层生成绘制列表，并将其提交到合成线程
	-	合成线程将图层分成图块，并在光栅化线程池中将图块换成位图
	-	合成线程发送绘制图块命令 DrawQuad给浏览器进程
	-	浏览器进程根据DrawQuad消息生成页面，并显示到显示器上

## 相关概念

三个和渲染流水线相关的概念：

- 重排

  更新元素的几何属性

  ![img](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png)

  修改元素的几何位置属性，例如改变宽度、高度，浏览器会出发重新布局，解析之后的一系列子阶段，这个过程就叫做重排，重排需要更新完整的渲染流水线，开销很大。

- 重绘

  更新元素的绘制属性

  ![img](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png)

  如果知识修改了元素的背景色等，那么布局阶段不会被执行，因为没有引起几何位置的变换，所以直接进入了绘制阶段，然后执行一系列子阶段，这个过程叫做重绘；和重排比较起来，省去了布局和分层阶段，开销会比重排小一些。

- 合成

  直接合成阶段

  ![img](https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png)

  使用css的transform实现的动画效果，可以避开重排和重绘的阶段，直接在非主线程上执行合成动画操作，开销最小。

​	

在优化Web性能的方法中，减少重绘、重排是一种很好的优化方式，那么结合文中的分析，你能总结出来为什么减少重绘、重排能优化Web性能吗？那又有那些具体的实践方法能减少重绘、重排呢？

- 触发repaint reflow的操作尽量放在一起，比如改变dom高度和设置margin分开写，可能会出发两次重排
- 通过虚拟dom层计算出操作总得差异，一起提交给浏览器。之前还用过createdocumentfragment来汇总append的dom,来减少触发重排重绘次数。

​			




# 几种简单的数据结构

- 数据
- 栈
- 队列
- 链表
- 树

先大概了解五种数据结构。

## 树组

#### 创建树组：

常用 `new Array`和`new Array(n).fill(data)`
```js
const arr = (new Array(7)).fill(1)
```

> fill使用引用类型的值进行填充，只会填充指针，存在引用数据类型的问题。
>
> 这个问题主要针对的是二维/多维树组。

#### 树组的访问和遍历

- 通过下标访问
- 通过`for循环`、`forEach`、`map`等遍历

## 栈和队列（特别的树组）

- 栈：（LIFO，Last In First Out）后进先出的数据结构。
  - push新增，从尾部添加
  - pop删除，从尾部删除
- 队列：（FIFO，First In First Out），先进先出的数据结构。
  - push新增，从尾部添加
  - shift删除，从头部删除

## 链表

概念：是有序的列表，线性的结构（有且仅有一个前驱、有且仅有一个后继），数据单位的名称叫做节点。

特点：链表中的节点在内存中可以是离散的。

> 和数组对比：
>
> - 数组在内存中是一段连续的内存，而链表可以是离散的（js数组不是真正的数组，是通过链表实现的）。
> - 链表增删操作快
> - 数组查询快

实现：链表中，每个节点的结构都包括数据域和指针域。

```js
{
    // 数据域
    val: 1,
    // 指针域，指向下一个结点
    next: {
        val:2,
        next: ...
    }
}   
```

### 链表和数组的辨析

数组：

- 查询是常数O

- 增加删除操作是O(n)

  > 由于数组在内存中是连续的，内存地址可以根据其索引距离数组头部的距离来计算出来，所以查询可以通过数组的索引下标直接定位，增删之后需要改变所有影响的元素，复杂度根据数组的长度程线性增长。

链表：

- 查询O(n)
- 增删O

> 在链表中，添加和删除操作的复杂度是固定的——不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向
>
> 但是链表也有一个弊端：当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。比如说我要在一个长度为 n（n>10） 的链表里，定位它的第 10 个结点，我需要这样做：

## 树

![img](https://s.poetries.work/images/20210905110841.png)

- **树的层次计算规则**：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。
- **结点和树的“高度”计算规则**：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。
- **“度”的概念**：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是3。
- **“叶子结点”**：叶子结点就是度为0的结点。在上图中，最后一层的结点的度全部为0，所以这一层的结点都是叶子结点。

### 二叉树

- 它可以没有根结点，作为一棵空树存在

- 如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。

  > 注意，二叉树不能被简单定义为每个结点的度都是2的树。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。

#### 二叉树遍历

以一定的顺序规则，逐个访问二叉树的所有节点，遍历方式主要有以下四种：

- 先序遍历
- 中序遍历 
- 后序遍历
- 层次遍历

按照实现方式的不同，遍历分为两种：

- 递归遍历(先、中、后序遍历)
- 迭代遍历（层次遍历

### 递归遍历

- 先序：根结点 -> 左子树 -> 右子树

- 中序左子树 -> 根结点 -> 右子树

- 后序：左子树 -> 右子树 -> 根结点

  > 三种顺序中，跟节点的遍历分别排在首要位置、中间位置和最后位置。

算法实现：

```js
// 二叉树
const root = {
  val: "A",
  left: {
    val: "B",
    left: {
      val: "D"
    },
    right: {
      val: "E"
    }
  },
  right: {
    val: "C",
    right: {
      val: "F"
    }
  }
};
// 先序遍历
// 所有遍历函数的入参都是树的根结点对象
function preorder(root){
   // 递归边界，root 为空
  if(!root) return
  // 输出当前遍历的节点值
  console.log("当前遍历的节点值是:",root.val)
  // 遍历左子树
  preorder(root.left)
  // 遍历右子树
  preorder(root.right)
}
// 中序遍历
function preorder(root){
  if(!root) return
  preorder(root.left)
  console.log("当前遍历的节点值是:",root.val)
  preorder(root.right)
}
// 后序遍历
function preorder(root){
  if(!root) return
  preorder(root.left)
  preorder(root.right)
  console.log("当前遍历的节点值是:",root.val)
}
```




# 几种简单的数据结构

- 数据
- 栈
- 队列
- 链表
- 树

先大概了解五种数据结构。

## 树组

#### 创建树组：

常用 `new Array`和`new Array(n).fill(data)`
```js
const arr = (new Array(7)).fill(1)
```

> fill使用引用类型的值进行填充，只会填充指针，存在引用数据类型的问题。
>
> 这个问题主要针对的是二维/多维树组。

#### 树组的访问和遍历

- 通过下标访问
- 通过`for循环`、`forEach`、`map`等遍历

## 栈和队列（特别的树组）

- 栈：（LIFO，Last In First Out）后进先出的数据结构。
  - push新增，从尾部添加
  - pop删除，从尾部删除
- 队列：（FIFO，First In First Out），先进先出的数据结构。
  - push新增，从尾部添加
  - shift删除，从头部删除

## 链表

概念：是有序的列表，线性的结构（有且仅有一个前驱、有且仅有一个后继），数据单位的名称叫做节点。

特点：链表中的节点在内存中可以是离散的。

> 和数组对比：
>
> - 数组在内存中是一段连续的内存，而链表可以是离散的（js数组不是真正的数组，是通过链表实现的）。
> - 链表增删操作快
> - 数组查询快

实现：链表中，每个节点的结构都包括数据域和指针域。

```js
{
    // 数据域
    val: 1,
    // 指针域，指向下一个结点
    next: {
        val:2,
        next: ...
    }
}   
```

### 链表和数组的辨析

数组：

- 查询是常数O

- 增加删除操作是O(n)

  > 由于数组在内存中是连续的，内存地址可以根据其索引距离数组头部的距离来计算出来，所以查询可以通过数组的索引下标直接定位，增删之后需要改变所有影响的元素，复杂度根据数组的长度程线性增长。

链表：

- 查询O(n)
- 增删O

> 在链表中，添加和删除操作的复杂度是固定的——不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向
>
> 但是链表也有一个弊端：当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它。比如说我要在一个长度为 n（n>10） 的链表里，定位它的第 10 个结点，我需要这样做：

# 算法复杂度

评价算法的重要依据：时间复杂度和空间复杂度。

## 时间复杂度

代码的执行次数，可以反映出代码的执行时间。

计算T(n) -> 推导O(n)

- 若 `T(n)` 是常数，那么无脑简化为1
- 若 `T(n)` 是多项式，比如 `3n^2 + 5n + 3`，我们只保留次数最高那一项，并且将其常数系数无脑改为1。

常见的时间复杂度，从小到大的顺序排列

![img](https://s.poetries.work/images/20210905111527.png)

## 空间复杂度

空间复杂度是对一个算法在运行过程中临时占用储存空间大小的度量。它是内存增常的趋势。

```js
function traverse(arr) {
    var len = arr.length
    for(var i=0;i<len;i++) {
        console.log(arr[i])
    }
}
```

> 后面尽管咱们做了很多次循环，但是这些都是时间上的开销。循环体在执行时，并没有开辟新的内存空间。因此，整个 traverse 函数对内存的占用量是恒定的，它对应的空间复杂度就是 O(1)。
>
> arr、len、i，只有这三个变量，且恒定

```js
function init(n) {
    var arr = []
    for(var i=0;i<n;i++) {
        arr[i] = i
    }
    return arr
}
```

> n、arr、i
>
> 注意这里这个 arr，它并不是一个一成不变的数组。arr最终的大小是由输入的 n 的大小决定的，它会随着 n 的增大而增大、呈一个线性关系。因此这个算法的空间复杂度就是 O(n)。

由此我们不难想象，假如需要初始化的是一个规模为 `n*n` 的数组，那么它的空间复杂度就是 `O(n^2)` 啦。

##  